"""Problem4.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1YApn10FuE5Pue86M1tLYHs7oqLsAYxl0
"""

!pip install ultralytics
import os
import pandas as pd
from ultralytics import YOLO


class InvalidPathError(Exception):
    """Custom exception for invalid paths."""
    pass

def get_bounding_boxes(model, image_path, conf=0.5):
    """
    Get the bounding boxes for objects in an image using the given YOLO model.

    Args:
        model (YOLO): The YOLO model.
        image_path (str): Path to the image file.
        conf (float, optional): Confidence threshold for object detection. Defaults to 0.5.

    Returns:
        list: A list of tuples containing the predicted class names and their corresponding bounding boxes.
    """
    try:
        results = model(image_path, conf=conf)
        output = [([result.names[int(box.cls)] for box in result.boxes], result.boxes.xyxy.tolist()) for result in results]
        return output
    except Exception as e:
        raise ValueError(f"Error processing image '{image_path}': {e}")

def load_yolov8_model(model_path):
    """
    Load the YOLOv8n model from the given model path.

    Args:
        model_path (str): Path to the YOLOv8n model file.

    Returns:
        YOLO: The loaded YOLOv8n model.
    """
    try:
        return YOLO(model_path)
    except Exception as e:
        raise InvalidPathError(f"Error loading model: {e}")

def find_all_classes(ideal_folder, model):
    """
    Find all unique classes (entities) in the images located in the "ideal_folder."

    Args:
        ideal_folder (str): Path to the folder containing the "ideal" images.
        model (YOLO): The YOLO model.

    Returns:
        set: A set containing all unique class names found in the "ideal" images.
    """
    if not os.path.exists(ideal_folder):
        raise ValueError(f"Ideal folder '{ideal_folder}' does not exist")

    all_classes = set()
    for ideal_file in os.listdir(ideal_folder):
        ideal_image_path = os.path.join(ideal_folder, ideal_file)
        if not os.path.isfile(ideal_image_path):
            continue
        ideal_boxes = get_bounding_boxes(model, ideal_image_path)
        ideal_classes = [class_name for class_names, _ in ideal_boxes for class_name in class_names]
        all_classes.update(ideal_classes)
    return all_classes

def find_missing_and_extra_entities(all_classes, other_folder, model):
    """
    Find missing and extra entities (object classes) in the images located in the "other_folder" relative to the "ideal_folder."

    Args:
        all_classes (set): A set containing all unique class names from the "ideal_folder" images.
        other_folder (str): Path to the folder containing the "other" images.
        model (YOLO): The YOLO model.

    Yields:
        tuple: A tuple containing the file name, missing entities, extra entities, and bounding boxes for each image in the "other_folder."
    """
    if not os.path.exists(other_folder):
        raise ValueError(f"Other folder '{other_folder}' does not exist")

    for other_file in os.listdir(other_folder):
        other_image_path = os.path.join(other_folder, other_file)
        if not os.path.isfile(other_image_path):
            continue
        other_boxes = get_bounding_boxes(model, other_image_path)
        other_classes = [class_name for class_names, _ in other_boxes for class_name in class_names]

        missing_entities = all_classes - set(other_classes)
        extra_entities = set(other_classes) - all_classes
        yield other_file, missing_entities, extra_entities, other_boxes

def create_dataframe(entity_set, difference_type, ideal_boxes, other_boxes):
    """
    Create a Pandas DataFrame containing information about the entities, the difference type, and the associated bounding boxes (if available).

    Args:
        entity_set (set): A set of entities (class names).
        difference_type (str): Type of difference, either 'missing' or 'extra'.
        ideal_boxes (list): List of tuples containing class names and bounding boxes for objects in the "ideal" images.
        other_boxes (list): List of tuples containing class names and bounding boxes for objects in the image.

    Returns:
        pd.DataFrame: The generated DataFrame.
    """
    meta_info = []
    for entity in entity_set:
        for class_names, boxes in other_boxes:
            if entity in class_names:
                meta_info.append([box for class_name, box in zip(class_names, boxes) if class_name == entity][0])
                break
        else:
            for class_names, boxes in ideal_boxes:
                if entity in class_names:
                    meta_info.append([box for class_name, box in zip(class_names, boxes) if class_name == entity][0])
                    break
            else:
                meta_info.append(None)

    df = pd.DataFrame({'Entity': list(entity_set),
                       'Difference': [difference_type] * len(entity_set),
                       'Meta': meta_info})
    return df

def compare_and_report(model, ideal_folder, other_folder, csv_output):
    """
    Compare bounding box predictions of the YOLO model on two sets of images and generate CSV reports.

    Args:
        model (YOLO): The YOLO model.
        ideal_folder (str): Path to the folder containing the "ideal" images.
        other_folder (str): Path to the folder containing the "other" images.
        csv_output (str): Path to the folder where CSV reports will be saved.
    """
    os.makedirs(csv_output, exist_ok=True)
    all_classes = find_all_classes(ideal_folder, model)

    batch_size = 16
    image_paths = [os.path.join(other_folder, f) for f in os.listdir(other_folder) if os.path.isfile(os.path.join(other_folder, f))]

    ideal_boxes = []
    for ideal_file in os.listdir(ideal_folder):
        ideal_image_path = os.path.join(ideal_folder, ideal_file)
        if os.path.isfile(ideal_image_path):
            ideal_boxes.extend(get_bounding_boxes(model, ideal_image_path))

    for i in range(0, len(image_paths), batch_size):
        batch_image_paths = image_paths[i:i + batch_size]
        batch_boxes = [get_bounding_boxes(model, image_path) for image_path in batch_image_paths]

        for j, other_image_path in enumerate(batch_image_paths):
            other_file = os.path.basename(other_image_path)
            other_boxes = batch_boxes[j]
            other_classes = [class_name for class_names, _ in other_boxes for class_name in class_names]

            missing_entities = all_classes - set(other_classes)
            extra_entities = set(other_classes) - all_classes

            missing_df = create_dataframe(missing_entities, 'missing', ideal_boxes, other_boxes)
            extra_df = create_dataframe(extra_entities, 'extra', ideal_boxes, other_boxes)
            df = pd.concat([missing_df, extra_df], ignore_index=True)

            csv_file_name = os.path.splitext(other_file)[0] + '.csv'
            csv_output_path = os.path.join(csv_output, csv_file_name)
            df.to_csv(csv_output_path, index=False)

if __name__ == "__main__":
    # Loading the YOLOv8n model
    model_path = 'yolov8n.pt'
    try:
        model = load_yolov8_model(model_path)

        # Defining paths for "Pizza" category
        ideal_folder_pizza = "Ads_Problem4/Pizza/Ideal"
        other_folder_pizza = "Ads_Problem4/Pizza/Other"
        csv_output_folder_pizza = "Ads_Problem4/Pizza/CSVs"

        # Defining paths for "Ramen" category
        ideal_folder_ramen = "Ads_Problem4/Ramen/Ideal"
        other_folder_ramen = "Ads_Problem4/Ramen/Other"
        csv_output_folder_ramen = "Ads_Problem4/Ramen/CSVs"

        # Comparing and generating reports for "Pizza" category
        compare_and_report(model, ideal_folder_pizza, other_folder_pizza, csv_output_folder_pizza)

        # Comparing and generating reports for "Ramen" category
        compare_and_report(model, ideal_folder_ramen, other_folder_ramen, csv_output_folder_ramen)

    except InvalidPathError as e:
        print(f"Error: {e}")
    except Exception as e:
        print(f"Unexpected error occurred: {e}")
